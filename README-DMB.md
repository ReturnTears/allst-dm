# 设计模式之美
```text
描述代码质量的词汇也有很多，⽐如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。

1、可维护性（maintainability），落实到编码开发，所谓的“维护”⽆外乎就是修改 bug、修改⽼的代码、添加新的代码之类的⼯作。
所谓“代码易维护”就是指，在不破坏原有代码设计、不引⼊新的 bug 的情况下，能够快速地修改或者添加代码。
所谓“代码不易维护”就是指，修改或者添加代码需要冒着极⼤的引⼊新 bug 的⻛险，并且需要花费很⻓的时间才能完成。

2、可读性（readability），落实到编码开发，可读性就是指代码的语义表达，⽐如变量、函数、类、模块、包等⽂档的语义表达。
我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在⾮常⼤程度上会影响代码的可维护性。
毕竟，不管是修改 bug，还是修改添加功能代码，我们⾸先要做的事情就是读懂代码。代码读不⼤懂，就很有可能因为考虑不周全，
⽽引⼊新的 bug。我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否⻓短合适、模块划分是否清晰、
是否符合⾼内聚低耦合等等。你应该也能感觉到，从正⾯上，我们很难给出⼀个覆盖所有评价指标的列表。这也是我们⽆法量化可读性的原因。

3、灵活（flexibility），落实到编码开发，所谓“灵活”就是指，代码的架构设计、模块划分、类、函数、变量等⽂档的语义表达。
如果⼀段代码易扩展、易复⽤或者易⽤，我们都可以称这段代码写得⽐较灵活。所以，灵活这个词的含义⾮常宽泛，很多场景下都可以使⽤。

4、可扩展性（extensibility），代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的⽅式添加新的功能代码。
说直⽩点就是，代码预留了⼀些功能扩展点，你可以把新功能代码，直接插到扩展点上，⽽不需要因为要添加⼀个功能⽽⼤动⼲⼽，改动⼤量的原始代码。

5、简洁性（simplicity），有⼀条⾮常著名的设计原则，你⼀定听过，那就是 KISS 原则：“Keep It Simple，Stupid”。
这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到⾸位。不过，很多编程经验不⾜的程序员会觉得，简单的
代码没有技术含量，喜欢在项⽬中引⼊⼀些复杂的设计模式，觉得这样才能体现⾃⼰的技术⽔平。实际上，思从深⽽⾏从简，
真正的⾼⼿能云淡⻛轻地⽤最简单的⽅法解决最复杂的问题。这也是⼀个编程⽼⼿跟编程新⼿的本质区别之⼀。

6、可复⽤性，代码的可复⽤性可以简单地理解为，尽量减少重复代码的编写，复⽤已有的代码。

7、可测试性，相对于前⾯六个评价标准，代码的可测试性是⼀个相对较少被提及，但⼜⾮常重要的代码质量评价标准。
代码可测试性的好坏，能从侧⾯上⾮常准确地反应代码质量的好坏。代码的可测试性差，⽐较难写单元测试，那基本上就能说明代码设计得有问题。

8、优雅（elegance），落实到编码开发，所谓“优雅”就是指，代码的语义表达，⽐如变量、函数、类、模块、包等⽂档的语义表达。

最常⽤到⼏个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复⽤性、可测试性。其
中，可维护性、可读性、可扩展性⼜是提到最多的、最重要的三个评价标准。
```
## ⾯向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？
```text
1、⾯向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。

2、设计原则是指导我们代码设计的⼀些经验总结，对于某些场景下，是否应该应⽤某种设计模式，具有指导意义。⽐如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。

3、设计模式是针对软件开发中经常遇到的⼀些设计问题，总结出来的⼀套解决⽅案或者设计思路。应⽤设计模式的主要⽬的是提⾼代码的可扩展性。从抽象程度上来讲，设计原则⽐设计模式更抽象。设计模式更加具体、更加可执⾏。

4、编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的⼩重构依赖的理论基础主要就是编程规范。

5、重构作为保持代码质量不下降的有效⼿段，利⽤的就是⾯向对象、设计原则、设计模式、编码规范这些理论。
实际上，⾯向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提⾼代码质量的⽅法论，本质上都是服务于编写⾼质量代码这⼀件事的。
```

## 面向对象
```text
编程范式：
1、面向过程
2、面向对象
3、函数式编程
```

## 什么是⾯向对象编程？
```text
⾯向对象编程的英⽂缩写是 OOP，全称是 Object Oriented Programming。对应地，⾯向对象编程语⾔的英⽂缩写是 OOPL，全称是 Object Oriented Programming Language。

⾯向对象编程中有两个⾮常重要、⾮常基础的概念，那就是类（class）和对象（object）。这两个概念最早出现在1960 年，在 Simula 这种编程语⾔中第⼀次使⽤。
⽽⾯向对象编程这个概念第⼀次被使⽤是在 Smalltalk 这种编程语⾔中。Smalltalk 被认为是第⼀个真正意义上的⾯向对象编程语⾔。

可以⽤下⾯两句话来概括:
1、⾯向对象编程是⼀种编程范式或编程⻛格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基⽯。

2、⾯向对象编程语⾔是⽀持类或对象的语法机制，并有现成的语法机制，能⽅便地实现⾯向对象编程四⼤特性（封装、抽象、继承、多态）的编程语⾔。

⾯向对象编程是⼀种编程范式或编程⻛格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基⽯。

面向对象四大特效

封装（Encapsulation）
封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接⼝，授权外部仅能通过类提供的⽅式来访问内部信息或者数据。
它需要编程语⾔提供权限访问控制语法来⽀持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，
⼀⽅⾯是保护数据不被随意修改，提⾼代码的可维护性；另⼀⽅⾯是仅暴露有限的必要接⼝，提⾼类的易⽤性。

抽象（Abstraction）
封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏⽅法的具体实现，让使⽤者只需要关⼼⽅法提供了哪些功能，
不需要知道这些功能是如何实现的。抽象可以通过接⼝类或者抽象类来实现，但也并不需要特殊的语法机制来⽀持。
抽象存在的意义，⼀⽅⾯是提⾼代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另⼀⽅⾯，
它也是处理复杂系统的有效⼿段，能有效地过滤掉不必要关注的信息。

继承（Inheritance）
继承是⽤来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示⼀个⼦类只继承⼀个⽗类，多继承表示⼀个⼦类可以继承多个⽗类。
为了实现继承这个特性，编程语⾔需要提供特殊的语法机制来⽀持。继承主要是⽤来解决代码复⽤的问题。

多态（Polymorphism）
多态是指⼦类可以替换⽗类，在实际的代码运⾏过程中，调⽤⼦类的⽅法实现。多态这种特性也需要编程语⾔提供特殊的语法机制来实现，
⽐如继承、接⼝类、duck-typing。多态可以提⾼代码的扩展性和复⽤性，是很多设计模式、设计原则、编程技巧的代码实现基础。

```

## 什么是面向对象编程语言？
```text
⾯向对象编程语⾔是⽀持类或对象的语法机制，并有现成的语法机制，能⽅便地实现⾯向对象编程四⼤特性（封装、抽象、继承、多态）的编程语⾔。

A.如何判定⼀个编程语⾔是否是⾯向对象编程语⾔？
如果按照严格的的定义，需要有现成的语法⽀持类、对象、四⼤特性才能叫作⾯向对象编程语⾔。如果放宽要求的话
，只要某种编程语⾔⽀持类、对象语法机制，那基本上就可以说这种编程语⾔是⾯向对象编程语⾔了，不⼀定⾮得要求具有所有的四⼤特性。

B.⾯向对象编程和⾯向对象编程语⾔之间有何关系？
⾯向对象编程⼀般使⽤⾯向对象编程语⾔来进⾏，但是，不⽤⾯向对象编程语⾔，我们照样可以进⾏⾯向对象编程。
反过来讲，即便我们使⽤⾯向对象编程语⾔，写出来的代码也不⼀定是⾯向对象编程⻛格的，也有可能是⾯向过程编程⻛格的。

C.什么是⾯向对象分析和⾯向对象设计？
简单点讲，⾯向对象分析就是要搞清楚做什么，⾯向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性⽅法、类与类之间如何交互等等。

```

## ⾯向对象编程相⽐⾯向过程编程有哪些优势？
```text
1、对于⼤规模复杂程序的开发，程序的处理流程并⾮单⼀的⼀条主线，⽽是错综复杂的⽹状结构。⾯向对象编程⽐起⾯向过程编程，更能应对这种复杂类型的程序开发。

2、⾯向对象编程相⽐⾯向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利⽤这些特性编写出来的代码，更加易扩展、易复⽤、易维护。

3、从编程语⾔跟机器打交道的⽅式的演进规律中，我们可以总结出：⾯向对象编程语⾔⽐起⾯向过程编程语⾔，更加⼈性化、更加⾼级、更加智能。
```

## Constants、Utils 类设计问题
```text
1、这样的设计会影响代码的可维护性。如果参与开发同⼀个项⽬的⼯程师有很多，在开发过程中，可能都要涉及修改这个类，⽐如往这个类⾥添加常量，
    那这个类就会变得越来越⼤，成百上千⾏都有可能，查找修改某个常量也会变得⽐较费时，⽽且还会增加提交代码冲突的概率。
    
2、这样的设计还会增加代码的编译时间。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。
    那每次修改 Constants 类，都会导致依赖它的类⽂件重新编译，因此会浪费很多不必要的编译时间。
    不要⼩看编译花费的时间，对于⼀个⾮常⼤的⼯程项⽬来说，编译⼀次项⽬花费的时间可能是⼏分钟，
    甚⾄⼏⼗分钟。⽽我们在开发过程中，每次运⾏单元测试，都会触发⼀次编译的过程，这个编译时间就有可能会影响到我们的开发效率。

3、这样的设计还会影响代码的复⽤性。如果我们要在另⼀个项⽬中，复⽤本项⽬开发的某个类，⽽这个类⼜依赖 Constants 类。
    即便这个类只依赖 Constants 类中的⼀⼩部分常量，我们仍然需要把整个Constants 类也⼀并引⼊，也就引⼊了很多⽆关的常量到新的项⽬中。
    
上述问题解决思路：
方式1：将 Constants 类拆解为功能更加单⼀的多个类，⽐如跟 MySQL 配置相关的常量，我们放到MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中。

方式2：不单独地设计 Constants 常量类，⽽是哪个类⽤到了某个常量，我们就把这个常量定义到这个类中。⽐如，RedisConfig 类⽤到了 Redis 配置相关的常量，那我们就直接将这些常量定义在RedisConfig 中，
    这样也提⾼了类设计的内聚性和代码的复⽤性。

Utils 类的出现是基于这样⼀个问题背景：如果我们有两个类 A 和 B，它们要⽤到⼀块相同的功能逻辑，为了避免代码重复。
实际上，只包含静态⽅法不包含任何属性的 Utils 类，是彻彻底底的⾯向过程的编程⻛格。
类⽐ Constants 类的设计，我们设计 Utils 类的时候，最好也能细化⼀下，针对不同的功能，设计不同的 Utils 类，⽐如 FileUtils、IOUtils、StringUtils、UrlUtils 等，不要设计⼀个过于⼤⽽全的 Utils 类。


```

## 抽象类和接⼝
```text
1、抽象类
a.抽象类不允许被实例化，只能被继承。也就是说，你不能 new ⼀个抽象类的对象出来。
b.抽象类可以包含属性和⽅法。⽅法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的⽅法叫作抽象⽅法。
c.⼦类继承抽象类，必须实现抽象类中的所有抽象⽅法。

2、接⼝特性
a.接⼝不能包含属性（也就是成员变量）。
b.接⼝只能声明⽅法，⽅法不能包含代码实现。(Java8+, 可以定义默认实现方法)
c.类实现接⼝的时候，必须实现接⼝中声明的所有⽅法。

抽象类实际上就是类，只不过是⼀种特殊的类，这种类不能被实例化为对象，只能被⼦类继承。我们知道，继承关系是⼀种 is-a 的关系，那抽象类既然属于类，也表示⼀种 is-a 的关系。
相对于抽象类的 is-a 关系来说，接⼝表示⼀种 has-a 关系，表示具有某些功能。对于接⼝，有⼀个更加形象的叫法，那就是协议（contract）。


```

## 抽象类和接⼝能解决什么编程问题
```text
抽象类更多的是为了代码复⽤，⽽接⼝就更侧重于解耦。接⼝是对⾏为的⼀种抽象，相当于⼀组协议或者契约，你可以联想类⽐⼀下 API 接⼝。
调⽤者只需要关注抽象的接⼝，不需要了解具体的实现，具体的实现代码对调⽤者透明。接⼝实现了约定和实现相分离，可以降低代码间的耦合性，提⾼代码的可扩展性。

抽象类是对成员变量和⽅法的抽象，是⼀种 is-a 关系，是为了解决代码复⽤问题。接⼝仅仅是对⽅法的抽象，是⼀种 has-a 关系，表示具有某⼀组⾏为特性，是为了解决解耦问题，隔离接⼝和具体的实现，提⾼代码的扩展性。

```

## 抽象类和接⼝的应⽤场景区别
```text
什么时候该⽤抽象类？什么时候该⽤接⼝？实际上，判断的标准很简单。如果要表示⼀种 is-a 的关系，并且是为了解决代码复⽤问题，我们就⽤抽象类；
如果要表示⼀种 has-a 关系，并且是为了解决抽象⽽⾮代码复⽤问题，那我们就⽤接⼝。

Is-A（继承关系）
概念："Is-a" 关系表示一个类（子类）是另一个类（父类）的一种特殊类型或者说是父类的一个子集。这种关系通过Java中的继承（extends关键字）来实现。子类继承父类的所有非私有属性和方法，同时还可以添加或重写父类的行为来体现自己的特异性。

示例：假设有一个基类 Animal，和一个继承自它的子类 Dog。在这里，我们可以表述为 "Dog is an Animal"。这意味着Dog类拥有Animal类的所有特征，比如吃、睡等基本行为，但可能还会有自己特有的行为，比如吠叫。

Has-A（组合关系）
概念："Has-a" 关系表示一个类包含另一个类的实例作为成员变量，表明第一个类“拥有”第二个类的一个对象。这种关系体现了类与类之间的组合或聚合关系，通常用于表示实体间的整体-部分关系或者关联关系。

示例：考虑一个 Car 类和一个 Engine 类。Car类中可以有一个Engine类型的成员变量，这表示“Car has an Engine”。这意味着每一个Car对象都包含一个Engine对象，用来描述汽车拥有的发动机这一特性。

区别总结
性质不同："Is-a" 描述的是类与类之间的继承关系，强调的是类型上的继承和扩展；而 "Has-a" 描述的是类与类之间的组合或聚合关系，强调的是对象包含对象的拥有关系。

设计影响："Is-a" 通常用于复用和扩展已有代码，实现代码的抽象和泛化；"Has-a" 则更多地用于表示对象之间的复杂关系，增强类的模块性和灵活性。
```

## 基于接⼝⽽⾮实现编程
```text
1. 实际上，“基于接⼝⽽⾮实现编程”这条原则的另⼀个表述⽅式，是“基于抽象⽽⾮实现编程”。后者的表述⽅式其实更能体现这条原则的设计初衷。
在软件开发中，最⼤的挑战之⼀就是需求的不断变化，这也是考验代码设计好坏的⼀个标准。越抽象、越顶层、越脱离具体某⼀实现的设计，越能提⾼代码的灵活性，越能应对未来的需求变化。
好的代码设计，不仅能应对当下的需求，⽽且在将来需求发⽣变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。⽽抽象就是提⾼代码扩展性、灵活性、可维护性最有效的⼿段之⼀。

2. 我们在定义接⼝的时候，⼀⽅⾯，命名要⾜够通⽤，不能包含跟具体实现相关的字眼；另⼀⽅⾯，与特定实现有关的⽅法不要定义在接⼝中。

3. “基于接⼝⽽⾮实现编程”这条原则，不仅仅可以指导⾮常细节的编程开发，还能指导更加上层的架构设计、系统设计等。⽐如，服务端与客户端之间的“接⼝”设计、类库的“接⼝”设计。
```

## 是否需要为每个类定义接口
```text
做任何事情都要讲求⼀个“度”，过度使⽤这条原则，⾮得给每个类都定义接⼝，接⼝满天⻜，也会导致不必要的开发负担。⾄于什么时候，该为某个类定义接⼝，实现基于接⼝的编程，什么时候不需要定义接⼝，直接使⽤实现类编程，
我们做权衡的根本依据，还是要回归到设计原则诞⽣的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题⽽产⽣的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。
从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有⼀种实现⽅式，未来也不可能被其他实现⽅式替换，那我们就没有必要为其设计接⼝，也没有必要基于接⼝编程，直接使⽤实现类就可以了。
除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投⼊不必要的开发时间。
```

## 为什么不推荐使⽤继承？
```text
在⾯向对象编程中，有⼀条⾮常经典的设计原则，那就是：组合优于继承，多⽤组合少⽤继承。为什么不推荐使⽤继承？组合相⽐继承有哪些优势？如何判断该⽤组合还是继承？
今天，我们就围绕着这三个问题，来详细讲解⼀下这条设计原则。
继承是⾯向对象的四⼤特性之⼀，⽤来表示类之间的 is-a 关系，可以解决代码复⽤的问题。虽然继承有诸多作⽤，
但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少⽤，甚⾄不⽤继承。
```

## 组合相⽐继承有哪些优势？
```text
我们知道继承主要有三个作⽤：表示 is-a 关系，⽀持多态特性，代码复⽤。⽽这三个作⽤都可以通过其他技术⼿段来达成。
⽐如 is-a 关系，我们可以通过组合和接⼝的 has-a 关系来替代；多态特性我们可以利⽤接⼝来实现；代码复⽤我们可以通过组合和委托来实现。
所以，从理论上讲，通过组合、接⼝、委托三个技术⼿段，我们完全可以替换掉继承，在项⽬中不⽤或者少⽤继承关系，特别是⼀些复杂的继承关系。
```

## 如何判断该⽤组合还是继承？
```text
尽管我们⿎励多⽤组合少⽤继承，但组合也并不是完美的，继承也并⾮⼀⽆是处。从上⾯的例⼦来看，继承改写成组合意味着要做更细粒度的类的拆分。
这也就意味着，我们要定义更多的类和接⼝。类和接⼝的增多也就或多或少地增加代码的复杂程度和维护成本。
所以，在实际的项⽬开发中，我们还是要根据具体的情况，来具体选择该⽤继承还是组合。

如果类之间的继承结构稳定（不会轻易改变），继承层次⽐较浅（⽐如，最多有两层继承关系），继承关系不复杂，我们就可以⼤胆地使⽤继承。
反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使⽤组合来替代继承。

除此之外，还有⼀些设计模式会固定使⽤继承或者组合。⽐如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、
组合模式（composite pattern）等都使⽤了组合关系，⽽模板模式（template pattern）使⽤了继承关系。

尽管有些⼈说，要杜绝继承，100% ⽤组合代替继承，但是我的观点没那么极端！之所以“多⽤组合少⽤继承”这个
⼝号喊得这么响，只是因为，⻓期以来，我们过度使⽤继承。还是那句话，组合并不完美，继承也不是⼀⽆是处。
只要我们控制好它们的副作⽤、发挥它们各⾃的优势，在不同的场合下，恰当地选择使⽤继承还是组合，这才是我们所追求的境界。
```

## 设计原则
```text
SOLID 原则

单⼀职责（Single Responsibility Principle）

开闭原则（Open Closed Principle）
```

## 单⼀职责（Single Responsibility Principle）
```text
单⼀职责（SRP）：Single Responsibility Principle，⼀个类只负责完成⼀个职责或者功能。不要设计⼤⽽全的类，要设计粒度⼩、功能单⼀的类。
单⼀职责原则是为了实现代码⾼内聚、低耦合，提⾼代码的复⽤性、可读性、可维护性。

从侧面判断一个类的职责是否够单一：
1、类中的代码⾏数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进⾏拆分；
2、类依赖的其他类过多，或者依赖类的其他类过多，不符合⾼内聚、低耦合的设计思想，我们就需要考虑对类进⾏拆分；
3、私有⽅法过多，我们就要考虑能否将私有⽅法ᇿ⽴到新的类中，设置为 public ⽅法，供更多的类使⽤，从⽽提⾼代码的复⽤性；
4、⽐较难给类起⼀个合适名字，很难⽤⼀个业务名词概括，或者只能⽤⼀些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
5、类中⼤量的⽅法都是集中操作类中的某⼏个属性，⽐如，在 UserInfo 例⼦中，如果⼀半的⽅法都是在操作address 信息，那就可以考虑将这⼏个属性和对应的⽅法拆分出来。

单⼀职责原则通过避免设计⼤⽽全的类，避免将不相关的功能耦合在⼀起，来提⾼类的内聚性。同时，类职责单⼀，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的⾼内聚、低耦合。
但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。

```

## 开闭原则（Open Closed Principle）
```text
开闭原则（OCP）：Open Closed Principle，对扩展开放，对修改关闭。添加⼀个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、⽅法、属性等），
⽽⾮修改已有代码（修改模块、类、⽅法、属性等）的⽅式来完成。关于定义，我们有两点要注意。
第⼀点是，开闭原则并不是说完全杜绝修改，⽽是以最⼩的修改代码的代价来完成新功能的开发。
第⼆点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能⼜被认定为“扩展”。

⽽且，我们要认识到，添加⼀个新功能，不可能任何模块、类、⽅法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做⼀些初始化操作，才能构建成可运⾏的的程序，这部分代码的修改是在所难免的。
我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核⼼、最复杂的那部分逻辑代码满⾜开闭原则。

如何做到“对扩展开放、修改关闭”？
我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考⼀下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、
做到最⼩代码改动的情况下，将新的代码灵活地插⼊到扩展点上。

很多设计原则、设计思想、设计模式，都是以提⾼代码的扩展性为最终⽬的的。特别是 23 种经典设计模式，⼤部分都是为了解决代码的扩展性问题⽽总结出来的，都是以开闭原则为指导原则的。
最常⽤来提⾼代码扩展性的⽅法有：多态、依赖注⼊、基于接⼝⽽⾮实现编程，以及⼤部分的设计模式（⽐如，装饰、策略、模板、职责链、状态）。

```

## ⾥式替换（Liskov Substitution Principle）
```text
⾥式替换（LSP）：⼦类对象（object of subtype/derived class）能够替换程序（program）中⽗类对象（objectof base/parent class）出现的任何地⽅，并且保证原来程序的逻辑⾏为（behavior）不变及正确性不被破坏。

⾥式替换原则是⽤来指导，继承关系中⼦类该如何设计的⼀个原则。理解⾥式替换原则，最核⼼的就是理解“design by contract，按照协议来设计”这⼏个字。⽗类定义了函数的“约定”（或者叫协议），那⼦类可以改变函数
的内部实现逻辑，但不能改变函数原有的“约定”。这⾥的约定包括：函数声明要实现的功能；对输⼊、输出、异常的约定；甚⾄包括注释中所罗列的任何特殊说明。

理解这个原则，我们还要弄明⽩⾥式替换原则跟多态的区别。虽然从定义描述和代码实现上来看，多态和⾥式替换有点类似，但它们关注的⻆度是不⼀样的。多态是⾯向对象编程的⼀⼤特性，也是⾯向对象编程语⾔的⼀种语法。
它是⼀种代码实现的思路。⽽⾥式替换是⼀种设计原则，⽤来指导继承关系中⼦类该如何设计，⼦类的设计要保证在替换⽗类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

```

## 接⼝隔离原则（Interface Segregation Principle）
```text
接⼝隔离原则（ISP）：调⽤⽅不应该被强迫依赖它不需要的接⼝。

```
## 依赖反转原则（Dependency Inversion Principle）
```text
依赖反转原则（DIP）： Dependency Inversion Principle ⾼层模块（high-level modules）不要依赖低层模块（low-level）。⾼层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。

1、控制反转
控制反转（IOC）: Inversion Of Control，框架提供了⼀个可扩展的代码⻣架，⽤来组装对象、管理整个执⾏流程。
程序员利⽤框架进⾏开发的时候，只需要往预留的扩展点上，添加跟⾃⼰业务相关的代码，就可以利⽤框架来驱动整个程序流程的执⾏。

2、依赖注⼊
依赖注⼊（DI）: Dependency Injection 依赖注⼊的⽅式来将依赖的类对象传递进来，这样就提⾼了代码的扩展性，我们可以灵活地替换依赖的类。
依赖注⼊和控制反转恰恰相反，它是⼀种具体的编码技巧。我们不通过 new 的⽅式在类内部创建依赖类的对象，
⽽是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等⽅式传递（或注⼊）给类来使⽤。

3、依赖注⼊框架
我们通过依赖注⼊框架提供的扩展点，简单配置⼀下所有需要的类及其类与类之间依赖关系，就可以实现由框架来⾃动创建对象、管理对象的⽣命周期、依赖注⼊等原本需要程序员来做的事情。

4、依赖反转原则
依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要⽤来指导框架层⾯的设计。⾼层模块不依赖低层模块，它们共同依赖同⼀个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

```

## KISS原则
```text
KISS 原则是保持代码可读和可维护的重要⼿段。KISS 原则中的“简单”并不是以代码⾏数来考量的。
代码⾏数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。

```

## 代码复用性
```text
1、减少代码耦合
对于⾼度耦合的代码，当我们希望复⽤其中的⼀个功能，想把这个功能的代码抽取出来成为⼀个ᇿ⽴的模块、类或者函数的时候，往往会发现牵⼀发⽽动全身。移动⼀点代码，就要牵连到很多其他相关的代码。所以，⾼度耦合的代码会影响到代码的复⽤性，我们要尽量减少代码耦合。

2、满⾜单⼀职责原则
如果职责不够单⼀，模块、类设计得⼤⽽全，那依赖它的代码或者它依赖的代码就会⽐较多，进⽽增加了代码的耦合。根据上⼀点，也就会影响到代码的复⽤性。相反，越细粒度的代码，代码的通⽤性会越好，越容易被复⽤。

3、模块化
这⾥的“模块”，不单单指⼀组类构成的模块，还可以理解为单个类、函数。我们要善于将功能ᇿ⽴的代码，封装成模块。独立的模块就像⼀块⼀块的积⽊，更加容易复⽤，可以直接拿来搭建更加复杂的系统。

4、业务与⾮业务逻辑分离
越是跟业务⽆关的代码越是容易复⽤，越是针对特定业务的代码越难复⽤。所以，为了复⽤跟业务⽆关的代码，我们将业务和⾮业务逻辑代码分离，抽取成⼀些通⽤的框架、类库、组件等。

5、通⽤代码下沉
从分层的⻆度来看，越底层的代码越通⽤、会被越多的模块调⽤，越应该设计得⾜够可复⽤。⼀般情况下，在代码分层之后，为了避免交叉调⽤导致调⽤关系混乱，
我们只允许上层代码调⽤下层代码及同层代码之间的调⽤，杜绝下层代码调⽤上层代码。所以，通⽤的代码我们尽量下沉到更下层。

6、继承、多态、抽象、封装
在讲⾯向对象特性的时候，我们讲到，利⽤继承，可以将公共的代码抽取到⽗类，⼦类复⽤⽗类的属性和⽅法。利⽤多态，我们可以动态地替换⼀段代码的部分逻辑，让这段代码可复⽤。除此之外，抽象和封装，
从更加⼴义的层⾯、⽽⾮ሀ义的⾯向对象特性的层⾯来理解的话，越抽象、越不依赖具体的实现，越容易复⽤。代码封装成模块，隐藏可变的细节、暴露不变的接⼝，就越容易复⽤。

7、应⽤模板等设计模式
⼀些设计模式，也能提⾼代码的复⽤性。⽐如，模板模式利⽤了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复⽤。


```

## 迪⽶特法则/最⼩知识原则
```text
迪⽶特法则的英⽂翻译是：Law of Demeter，缩写是 LOD。也叫作最⼩知识原则，英⽂翻译为：The LeastKnowledge Principle。
不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接⼝（也就是定义中的“有限知识”）。

1、如何理解“⾼内聚、松耦合”？
“⾼内聚、松耦合”是⼀个⾮常重要的设计思想，能够有效提⾼代码的可读性和可维护性，缩⼩功能改动导致的代码改动范围。“⾼内聚”⽤来指导类本身的设计，“松耦合”⽤来指导类与类之间依赖关系的设计。
所谓⾼内聚，就是指相近的功能应该放到同⼀个类中，不相近的功能不要放到同⼀类中。相近的功能往往会被同时修改，放到同⼀个类中，修改会⽐较集中。
所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，⼀个类的代码改动也不会或者很少导致依赖类的代码改动。

2、如何理解“迪⽶特法则”？
不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接⼝。迪⽶特法则是希望减少类之间的耦合，让类越ᇿ⽴越好。每个类都应该少了解系统的其他部分。⼀旦发⽣变化，需要了解这⼀变化的类就会⽐较少。


```

## 为什么要分 MVC 三层开发？
```text
1、分层能起到代码复⽤的作⽤
同⼀个 Repository 可能会被多个 Service 来调⽤，同⼀个 Service 可能会被多个 Controller 调⽤。
⽐如，UserService 中的 getUserById() 接⼝封装了通过 ID 获取⽤户信息的逻辑，这部分逻辑可能会被 UserController和 AdminController 等多个 Controller 使⽤。如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，
显然会违反 DRY 原则。

2、分层能起到隔离变化的作⽤
分层体现了⼀种抽象和封装的设计思想。⽐如，Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接⼝。
基于接⼝⽽⾮实现编程的设计思想，Service 层使⽤ Repository 层提供的接⼝，并不关⼼其底层依赖的是哪种具体的数据库。
当我们需要替换数据库的时候，⽐如从 MySQL 到 Oracle，从 Oracle 到 Redis，只需要改动Repository 层的代码，Service 层的代码完全不需要修改。

除此之外，Controller、Service、Repository 三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地隔离变化。
⽐如，Repository 层基于数据库表，⽽数据库表改动的可能性很⼩，所以Repository 层的代码最稳定，⽽ Controller 层提供适配给外部使⽤的接⼝，代码经常会变动。
分层之后，Controller 层中代码的频繁改动并不会影响到稳定的 Repository 层。

3、分层能起到隔离关注点的作⽤
Repository 层只关注数据的读写。Service 层只关注业务逻辑，不关注数据的来源。Controller 层只关注与外界打交道，数据校验、封装、格式转换，并不关⼼业务逻辑。
三层之间的关注点不同，分层之后，职责分明，更加符合单⼀职责原则，代码的内聚性更好。

4、分层能提⾼代码的可测试性
分层之后，Repsitory 层的代码通过依赖注⼊的⽅式供 Service 层使⽤，当要测试包含核⼼业务逻辑的 Service 层代码的时候，我们可以⽤mock 的数据源替代真实的数据库，注⼊到 Service 层代码中。

5、分层能应对系统的复杂性
所有的代码都放到⼀个类中，那这个类的代码就会因为需求的迭代⽽⽆限膨胀。我们知道，当⼀个类或⼀个函数的代码过多之后，可读性、可维护性就会变差。那我们就要想办法拆分。拆分有垂直和⽔平两个⽅向。
⽔平⽅向基于业务来做拆分，就是模块化；垂直⽅向基于流程来做拆分，就是这⾥说的分层。

还是那句话，不管是分层、模块化，还是 OOP、DDD，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。


```

## BO、VO、Entity 存在的意义是什么？
```text
针对 Controller、Service、Repository 三层，每层都会定义相应的数据对象，它们分别是 VO（View Object）、BO（Business Object）、Entity，例如 UserVo、UserBo、UserEntity。
在实际的开发中，VO、BO、Entity 可能存在⼤量的重复字段，甚⾄三者包含的字段完全⼀样。在开发的过程中，我们经常需要重复定义三个⼏乎⼀样的类，显然是⼀种重复劳动。

1、相对于每层定义各⾃的数据对象来说，是不是定义⼀个公共的数据对象更好些呢？
实际上，我更加推荐每层都定义各⾃的数据对象这种设计思路，主要有以下 3 个⽅⾯的原因。
a.VO、BO、Entity 并⾮完全⼀样。⽐如，我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将⽤户的密码暴露出去。
b.VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不⼀样的。所以，也并不能算违背DRY 原则。在前⾯讲到 DRY 原则的时候，针对这种情况，如果合并为同⼀个类，那也会存在后期因为需求的变化⽽需要再拆分的问题。
c.为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护⾃⼰的数据对象，层与层之间通过接⼝交互。数据从下⼀层传递到上⼀层的时候，将下⼀层的数据对象转化成上⼀层的数据对象，再继续处理。虽
然这样的设计稍微有些繁琐，每层都需要定义各⾃的数据对象，需要做数据对象之间的转化，但是分层清晰。对于⾮常⼤的项⽬来说，结构清晰是第⼀位的！

2、既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？
从设计的⻆度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减少耦合，多维护⼏个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们也有⼀些办法来解决。
我们前⾯讲到，继承可以解决代码重复问题。我们可以将公共的字段定义在⽗类中，让 VO、BO、Entity 都继承这个⽗类，各⾃只定义特有的字段。因为这⾥的继承层次很浅，也不复杂，所以使⽤继承并不会影响代码的可读性和可维护性。
后期如果因为业务的需要，有些字段需要从⽗类移动到⼦类，或者从⼦类提取到⽗类，代码改起来也并不复杂。

前⾯在讲“多⽤组合，少⽤继承”设计思想的时候，我们提到，组合也可以解决代码重复的问题，所以，这⾥我们还可以将公共的字段抽取到公共的类中，VO、BO、Entity 通过组合关系来复⽤这个类的代码。

3、代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？
当下⼀层的数据通过接⼝调⽤传递到上⼀层之后，我们需要将它转化成上⼀层对应的数据对象类型。⽐如，Service 层从 Repository 层获取的 Entity 之后，将其转化成 BO，再继续业务逻辑的处理。
所以，整个开发的过程会涉及“Entity 到 BO”和“BO 到 VO”这两种转化。

VO、BO、Entity 都是基于贫⾎模型的，⽽且为了兼容框架或开发库（⽐如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set ⽅法。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？

前⾯我们也提到过，Entity 和 VO 的⽣命周期是有限的，都仅限在本层范围内。⽽对应的 Repository 层和Controller 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫⾎、定义每个字段的set ⽅法，相对来说也是安全的。

不过，Service 层包含⽐较多的业务逻辑代码，所以 BO 就存在被任意修改的⻛险了。但是，设计的问题本身就没有最优解，只有权衡。为了使⽤⽅便，我们只能做⼀些妥协，放弃 BO 的封装特性，由程序员⾃⼰来负责这些数据对象的不被错误使⽤。


```