# 设计模式之美
```text
描述代码质量的词汇也有很多，⽐如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。

1、可维护性（maintainability），落实到编码开发，所谓的“维护”⽆外乎就是修改 bug、修改⽼的代码、添加新的代码之类的⼯作。
所谓“代码易维护”就是指，在不破坏原有代码设计、不引⼊新的 bug 的情况下，能够快速地修改或者添加代码。
所谓“代码不易维护”就是指，修改或者添加代码需要冒着极⼤的引⼊新 bug 的⻛险，并且需要花费很⻓的时间才能完成。

2、可读性（readability），落实到编码开发，可读性就是指代码的语义表达，⽐如变量、函数、类、模块、包等⽂档的语义表达。
我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在⾮常⼤程度上会影响代码的可维护性。
毕竟，不管是修改 bug，还是修改添加功能代码，我们⾸先要做的事情就是读懂代码。代码读不⼤懂，就很有可能因为考虑不周全，
⽽引⼊新的 bug。我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否⻓短合适、模块划分是否清晰、
是否符合⾼内聚低耦合等等。你应该也能感觉到，从正⾯上，我们很难给出⼀个覆盖所有评价指标的列表。这也是我们⽆法量化可读性的原因。

3、灵活（flexibility），落实到编码开发，所谓“灵活”就是指，代码的架构设计、模块划分、类、函数、变量等⽂档的语义表达。
如果⼀段代码易扩展、易复⽤或者易⽤，我们都可以称这段代码写得⽐较灵活。所以，灵活这个词的含义⾮常宽泛，很多场景下都可以使⽤。

4、可扩展性（extensibility），代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的⽅式添加新的功能代码。
说直⽩点就是，代码预留了⼀些功能扩展点，你可以把新功能代码，直接插到扩展点上，⽽不需要因为要添加⼀个功能⽽⼤动⼲⼽，改动⼤量的原始代码。

5、简洁性（simplicity），有⼀条⾮常著名的设计原则，你⼀定听过，那就是 KISS 原则：“Keep It Simple，Stupid”。
这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到⾸位。不过，很多编程经验不⾜的程序员会觉得，简单的
代码没有技术含量，喜欢在项⽬中引⼊⼀些复杂的设计模式，觉得这样才能体现⾃⼰的技术⽔平。实际上，思从深⽽⾏从简，
真正的⾼⼿能云淡⻛轻地⽤最简单的⽅法解决最复杂的问题。这也是⼀个编程⽼⼿跟编程新⼿的本质区别之⼀。

6、可复⽤性，代码的可复⽤性可以简单地理解为，尽量减少重复代码的编写，复⽤已有的代码。

7、可测试性，相对于前⾯六个评价标准，代码的可测试性是⼀个相对较少被提及，但⼜⾮常重要的代码质量评价标准。
代码可测试性的好坏，能从侧⾯上⾮常准确地反应代码质量的好坏。代码的可测试性差，⽐较难写单元测试，那基本上就能说明代码设计得有问题。

8、优雅（elegance），落实到编码开发，所谓“优雅”就是指，代码的语义表达，⽐如变量、函数、类、模块、包等⽂档的语义表达。

最常⽤到⼏个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复⽤性、可测试性。其
中，可维护性、可读性、可扩展性⼜是提到最多的、最重要的三个评价标准。
```
## ⾯向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？
```text
1、⾯向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。

2、设计原则是指导我们代码设计的⼀些经验总结，对于某些场景下，是否应该应⽤某种设计模式，具有指导意义。⽐如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。

3、设计模式是针对软件开发中经常遇到的⼀些设计问题，总结出来的⼀套解决⽅案或者设计思路。应⽤设计模式的主要⽬的是提⾼代码的可扩展性。从抽象程度上来讲，设计原则⽐设计模式更抽象。设计模式更加具体、更加可执⾏。

4、编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的⼩重构依赖的理论基础主要就是编程规范。

5、重构作为保持代码质量不下降的有效⼿段，利⽤的就是⾯向对象、设计原则、设计模式、编码规范这些理论。
实际上，⾯向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提⾼代码质量的⽅法论，本质上都是服务于编写⾼质量代码这⼀件事的。
```

## 面向对象
```text
编程范式：
1、面向过程
2、面向对象
3、函数式编程
```

## 什么是⾯向对象编程？
```text
⾯向对象编程的英⽂缩写是 OOP，全称是 Object Oriented Programming。对应地，⾯向对象编程语⾔的英⽂缩写是 OOPL，全称是 Object Oriented Programming Language。

⾯向对象编程中有两个⾮常重要、⾮常基础的概念，那就是类（class）和对象（object）。这两个概念最早出现在1960 年，在 Simula 这种编程语⾔中第⼀次使⽤。
⽽⾯向对象编程这个概念第⼀次被使⽤是在 Smalltalk 这种编程语⾔中。Smalltalk 被认为是第⼀个真正意义上的⾯向对象编程语⾔。

可以⽤下⾯两句话来概括:
1、⾯向对象编程是⼀种编程范式或编程⻛格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基⽯。

2、⾯向对象编程语⾔是⽀持类或对象的语法机制，并有现成的语法机制，能⽅便地实现⾯向对象编程四⼤特性（封装、抽象、继承、多态）的编程语⾔。

⾯向对象编程是⼀种编程范式或编程⻛格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基⽯。

面向对象四大特效

封装（Encapsulation）
封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接⼝，授权外部仅能通过类提供的⽅式来访问内部信息或者数据。
它需要编程语⾔提供权限访问控制语法来⽀持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，
⼀⽅⾯是保护数据不被随意修改，提⾼代码的可维护性；另⼀⽅⾯是仅暴露有限的必要接⼝，提⾼类的易⽤性。

抽象（Abstraction）
封装主要讲如何隐藏信息、保护数据，那抽象就是讲如何隐藏⽅法的具体实现，让使⽤者只需要关⼼⽅法提供了哪些功能，
不需要知道这些功能是如何实现的。抽象可以通过接⼝类或者抽象类来实现，但也并不需要特殊的语法机制来⽀持。
抽象存在的意义，⼀⽅⾯是提⾼代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另⼀⽅⾯，
它也是处理复杂系统的有效⼿段，能有效地过滤掉不必要关注的信息。

继承（Inheritance）
继承是⽤来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。单继承表示⼀个⼦类只继承⼀个⽗类，多继承表示⼀个⼦类可以继承多个⽗类。
为了实现继承这个特性，编程语⾔需要提供特殊的语法机制来⽀持。继承主要是⽤来解决代码复⽤的问题。

多态（Polymorphism）
多态是指⼦类可以替换⽗类，在实际的代码运⾏过程中，调⽤⼦类的⽅法实现。多态这种特性也需要编程语⾔提供特殊的语法机制来实现，
⽐如继承、接⼝类、duck-typing。多态可以提⾼代码的扩展性和复⽤性，是很多设计模式、设计原则、编程技巧的代码实现基础。

```

## 什么是面向对象编程语言？
```text
⾯向对象编程语⾔是⽀持类或对象的语法机制，并有现成的语法机制，能⽅便地实现⾯向对象编程四⼤特性（封装、抽象、继承、多态）的编程语⾔。

A.如何判定⼀个编程语⾔是否是⾯向对象编程语⾔？
如果按照严格的的定义，需要有现成的语法⽀持类、对象、四⼤特性才能叫作⾯向对象编程语⾔。如果放宽要求的话
，只要某种编程语⾔⽀持类、对象语法机制，那基本上就可以说这种编程语⾔是⾯向对象编程语⾔了，不⼀定⾮得要求具有所有的四⼤特性。

B.⾯向对象编程和⾯向对象编程语⾔之间有何关系？
⾯向对象编程⼀般使⽤⾯向对象编程语⾔来进⾏，但是，不⽤⾯向对象编程语⾔，我们照样可以进⾏⾯向对象编程。
反过来讲，即便我们使⽤⾯向对象编程语⾔，写出来的代码也不⼀定是⾯向对象编程⻛格的，也有可能是⾯向过程编程⻛格的。

C.什么是⾯向对象分析和⾯向对象设计？
简单点讲，⾯向对象分析就是要搞清楚做什么，⾯向对象设计就是要搞清楚怎么做。两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性⽅法、类与类之间如何交互等等。

```

## ⾯向对象编程相⽐⾯向过程编程有哪些优势？
```text
1、对于⼤规模复杂程序的开发，程序的处理流程并⾮单⼀的⼀条主线，⽽是错综复杂的⽹状结构。⾯向对象编程⽐起⾯向过程编程，更能应对这种复杂类型的程序开发。

2、⾯向对象编程相⽐⾯向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利⽤这些特性编写出来的代码，更加易扩展、易复⽤、易维护。

3、从编程语⾔跟机器打交道的⽅式的演进规律中，我们可以总结出：⾯向对象编程语⾔⽐起⾯向过程编程语⾔，更加⼈性化、更加⾼级、更加智能。
```

## Constants、Utils 类设计问题
```text
1、这样的设计会影响代码的可维护性。如果参与开发同⼀个项⽬的⼯程师有很多，在开发过程中，可能都要涉及修改这个类，⽐如往这个类⾥添加常量，
    那这个类就会变得越来越⼤，成百上千⾏都有可能，查找修改某个常量也会变得⽐较费时，⽽且还会增加提交代码冲突的概率。
    
2、这样的设计还会增加代码的编译时间。当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。
    那每次修改 Constants 类，都会导致依赖它的类⽂件重新编译，因此会浪费很多不必要的编译时间。
    不要⼩看编译花费的时间，对于⼀个⾮常⼤的⼯程项⽬来说，编译⼀次项⽬花费的时间可能是⼏分钟，
    甚⾄⼏⼗分钟。⽽我们在开发过程中，每次运⾏单元测试，都会触发⼀次编译的过程，这个编译时间就有可能会影响到我们的开发效率。

3、这样的设计还会影响代码的复⽤性。如果我们要在另⼀个项⽬中，复⽤本项⽬开发的某个类，⽽这个类⼜依赖 Constants 类。
    即便这个类只依赖 Constants 类中的⼀⼩部分常量，我们仍然需要把整个Constants 类也⼀并引⼊，也就引⼊了很多⽆关的常量到新的项⽬中。
    
上述问题解决思路：
方式1：将 Constants 类拆解为功能更加单⼀的多个类，⽐如跟 MySQL 配置相关的常量，我们放到MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中。

方式2：不单独地设计 Constants 常量类，⽽是哪个类⽤到了某个常量，我们就把这个常量定义到这个类中。⽐如，RedisConfig 类⽤到了 Redis 配置相关的常量，那我们就直接将这些常量定义在RedisConfig 中，
    这样也提⾼了类设计的内聚性和代码的复⽤性。

Utils 类的出现是基于这样⼀个问题背景：如果我们有两个类 A 和 B，它们要⽤到⼀块相同的功能逻辑，为了避免代码重复。
实际上，只包含静态⽅法不包含任何属性的 Utils 类，是彻彻底底的⾯向过程的编程⻛格。
类⽐ Constants 类的设计，我们设计 Utils 类的时候，最好也能细化⼀下，针对不同的功能，设计不同的 Utils 类，⽐如 FileUtils、IOUtils、StringUtils、UrlUtils 等，不要设计⼀个过于⼤⽽全的 Utils 类。


```

## 抽象类和接⼝
```text
1、抽象类
a.抽象类不允许被实例化，只能被继承。也就是说，你不能 new ⼀个抽象类的对象出来。
b.抽象类可以包含属性和⽅法。⽅法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的⽅法叫作抽象⽅法。
c.⼦类继承抽象类，必须实现抽象类中的所有抽象⽅法。

2、接⼝特性
a.接⼝不能包含属性（也就是成员变量）。
b.接⼝只能声明⽅法，⽅法不能包含代码实现。(Java8+, 可以定义默认实现方法)
c.类实现接⼝的时候，必须实现接⼝中声明的所有⽅法。

抽象类实际上就是类，只不过是⼀种特殊的类，这种类不能被实例化为对象，只能被⼦类继承。我们知道，继承关系是⼀种 is-a 的关系，那抽象类既然属于类，也表示⼀种 is-a 的关系。
相对于抽象类的 is-a 关系来说，接⼝表示⼀种 has-a 关系，表示具有某些功能。对于接⼝，有⼀个更加形象的叫法，那就是协议（contract）。


```

## 抽象类和接⼝能解决什么编程问题
```text
抽象类更多的是为了代码复⽤，⽽接⼝就更侧重于解耦。接⼝是对⾏为的⼀种抽象，相当于⼀组协议或者契约，你可以联想类⽐⼀下 API 接⼝。
调⽤者只需要关注抽象的接⼝，不需要了解具体的实现，具体的实现代码对调⽤者透明。接⼝实现了约定和实现相分离，可以降低代码间的耦合性，提⾼代码的可扩展性。

抽象类是对成员变量和⽅法的抽象，是⼀种 is-a 关系，是为了解决代码复⽤问题。接⼝仅仅是对⽅法的抽象，是⼀种 has-a 关系，表示具有某⼀组⾏为特性，是为了解决解耦问题，隔离接⼝和具体的实现，提⾼代码的扩展性。

```

## 抽象类和接⼝的应⽤场景区别
```text
什么时候该⽤抽象类？什么时候该⽤接⼝？实际上，判断的标准很简单。如果要表示⼀种 is-a 的关系，并且是为了解决代码复⽤问题，我们就⽤抽象类；
如果要表示⼀种 has-a 关系，并且是为了解决抽象⽽⾮代码复⽤问题，那我们就⽤接⼝。

Is-A（继承关系）
概念："Is-a" 关系表示一个类（子类）是另一个类（父类）的一种特殊类型或者说是父类的一个子集。这种关系通过Java中的继承（extends关键字）来实现。子类继承父类的所有非私有属性和方法，同时还可以添加或重写父类的行为来体现自己的特异性。

示例：假设有一个基类 Animal，和一个继承自它的子类 Dog。在这里，我们可以表述为 "Dog is an Animal"。这意味着Dog类拥有Animal类的所有特征，比如吃、睡等基本行为，但可能还会有自己特有的行为，比如吠叫。

Has-A（组合关系）
概念："Has-a" 关系表示一个类包含另一个类的实例作为成员变量，表明第一个类“拥有”第二个类的一个对象。这种关系体现了类与类之间的组合或聚合关系，通常用于表示实体间的整体-部分关系或者关联关系。

示例：考虑一个 Car 类和一个 Engine 类。Car类中可以有一个Engine类型的成员变量，这表示“Car has an Engine”。这意味着每一个Car对象都包含一个Engine对象，用来描述汽车拥有的发动机这一特性。

区别总结
性质不同："Is-a" 描述的是类与类之间的继承关系，强调的是类型上的继承和扩展；而 "Has-a" 描述的是类与类之间的组合或聚合关系，强调的是对象包含对象的拥有关系。

设计影响："Is-a" 通常用于复用和扩展已有代码，实现代码的抽象和泛化；"Has-a" 则更多地用于表示对象之间的复杂关系，增强类的模块性和灵活性。
```

## 基于接⼝⽽⾮实现编程
```text
1. 实际上，“基于接⼝⽽⾮实现编程”这条原则的另⼀个表述⽅式，是“基于抽象⽽⾮实现编程”。后者的表述⽅式其实更能体现这条原则的设计初衷。
在软件开发中，最⼤的挑战之⼀就是需求的不断变化，这也是考验代码设计好坏的⼀个标准。越抽象、越顶层、越脱离具体某⼀实现的设计，越能提⾼代码的灵活性，越能应对未来的需求变化。
好的代码设计，不仅能应对当下的需求，⽽且在将来需求发⽣变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。⽽抽象就是提⾼代码扩展性、灵活性、可维护性最有效的⼿段之⼀。

2. 我们在定义接⼝的时候，⼀⽅⾯，命名要⾜够通⽤，不能包含跟具体实现相关的字眼；另⼀⽅⾯，与特定实现有关的⽅法不要定义在接⼝中。

3. “基于接⼝⽽⾮实现编程”这条原则，不仅仅可以指导⾮常细节的编程开发，还能指导更加上层的架构设计、系统设计等。⽐如，服务端与客户端之间的“接⼝”设计、类库的“接⼝”设计。
```

## 是否需要为每个类定义接口
```text
做任何事情都要讲求⼀个“度”，过度使⽤这条原则，⾮得给每个类都定义接⼝，接⼝满天⻜，也会导致不必要的开发负担。⾄于什么时候，该为某个类定义接⼝，实现基于接⼝的编程，什么时候不需要定义接⼝，直接使⽤实现类编程，
我们做权衡的根本依据，还是要回归到设计原则诞⽣的初衷上来。只要搞清楚了这条原则是为了解决什么样的问题⽽产⽣的，你就会发现，很多之前模棱两可的问题，都会变得豁然开朗。
从这个设计初衷上来看，如果在我们的业务场景中，某个功能只有⼀种实现⽅式，未来也不可能被其他实现⽅式替换，那我们就没有必要为其设计接⼝，也没有必要基于接⼝编程，直接使⽤实现类就可以了。
除此之外，越是不稳定的系统，我们越是要在代码的扩展性、维护性上下功夫。相反，如果某个系统特别稳定，在开发完之后，基本上不需要做维护，那我们就没有必要为其扩展性，投⼊不必要的开发时间。
```

## 为什么不推荐使⽤继承？
```text
在⾯向对象编程中，有⼀条⾮常经典的设计原则，那就是：组合优于继承，多⽤组合少⽤继承。为什么不推荐使⽤继承？组合相⽐继承有哪些优势？如何判断该⽤组合还是继承？
今天，我们就围绕着这三个问题，来详细讲解⼀下这条设计原则。
继承是⾯向对象的四⼤特性之⼀，⽤来表示类之间的 is-a 关系，可以解决代码复⽤的问题。虽然继承有诸多作⽤，
但继承层次过深、过复杂，也会影响到代码的可维护性。在这种情况下，我们应该尽量少⽤，甚⾄不⽤继承。
```

## 组合相⽐继承有哪些优势？
```text
我们知道继承主要有三个作⽤：表示 is-a 关系，⽀持多态特性，代码复⽤。⽽这三个作⽤都可以通过其他技术⼿段来达成。
⽐如 is-a 关系，我们可以通过组合和接⼝的 has-a 关系来替代；多态特性我们可以利⽤接⼝来实现；代码复⽤我们可以通过组合和委托来实现。
所以，从理论上讲，通过组合、接⼝、委托三个技术⼿段，我们完全可以替换掉继承，在项⽬中不⽤或者少⽤继承关系，特别是⼀些复杂的继承关系。
```

## 如何判断该⽤组合还是继承？
```text
尽管我们⿎励多⽤组合少⽤继承，但组合也并不是完美的，继承也并⾮⼀⽆是处。从上⾯的例⼦来看，继承改写成组合意味着要做更细粒度的类的拆分。
这也就意味着，我们要定义更多的类和接⼝。类和接⼝的增多也就或多或少地增加代码的复杂程度和维护成本。
所以，在实际的项⽬开发中，我们还是要根据具体的情况，来具体选择该⽤继承还是组合。

如果类之间的继承结构稳定（不会轻易改变），继承层次⽐较浅（⽐如，最多有两层继承关系），继承关系不复杂，我们就可以⼤胆地使⽤继承。
反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使⽤组合来替代继承。

除此之外，还有⼀些设计模式会固定使⽤继承或者组合。⽐如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、
组合模式（composite pattern）等都使⽤了组合关系，⽽模板模式（template pattern）使⽤了继承关系。

尽管有些⼈说，要杜绝继承，100% ⽤组合代替继承，但是我的观点没那么极端！之所以“多⽤组合少⽤继承”这个
⼝号喊得这么响，只是因为，⻓期以来，我们过度使⽤继承。还是那句话，组合并不完美，继承也不是⼀⽆是处。
只要我们控制好它们的副作⽤、发挥它们各⾃的优势，在不同的场合下，恰当地选择使⽤继承还是组合，这才是我们所追求的境界。
```

## 设计原则
```text
SOLID 原则

单⼀职责（Single Responsibility Principle）

开闭原则（Open Closed Principle）
```

## 单⼀职责（Single Responsibility Principle）
```text
单⼀职责（SRP）：Single Responsibility Principle，⼀个类只负责完成⼀个职责或者功能。不要设计⼤⽽全的类，要设计粒度⼩、功能单⼀的类。
单⼀职责原则是为了实现代码⾼内聚、低耦合，提⾼代码的复⽤性、可读性、可维护性。

从侧面判断一个类的职责是否够单一：
1、类中的代码⾏数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进⾏拆分；
2、类依赖的其他类过多，或者依赖类的其他类过多，不符合⾼内聚、低耦合的设计思想，我们就需要考虑对类进⾏拆分；
3、私有⽅法过多，我们就要考虑能否将私有⽅法ᇿ⽴到新的类中，设置为 public ⽅法，供更多的类使⽤，从⽽提⾼代码的复⽤性；
4、⽐较难给类起⼀个合适名字，很难⽤⼀个业务名词概括，或者只能⽤⼀些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；
5、类中⼤量的⽅法都是集中操作类中的某⼏个属性，⽐如，在 UserInfo 例⼦中，如果⼀半的⽅法都是在操作address 信息，那就可以考虑将这⼏个属性和对应的⽅法拆分出来。

单⼀职责原则通过避免设计⼤⽽全的类，避免将不相关的功能耦合在⼀起，来提⾼类的内聚性。同时，类职责单⼀，类依赖的和被依赖的其他类也会变少，减少了代码的耦合性，以此来实现代码的⾼内聚、低耦合。
但是，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。

```

## 开闭原则（Open Closed Principle）
```text
开闭原则（OCP）：Open Closed Principle，对扩展开放，对修改关闭。添加⼀个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、⽅法、属性等），
⽽⾮修改已有代码（修改模块、类、⽅法、属性等）的⽅式来完成。关于定义，我们有两点要注意。
第⼀点是，开闭原则并不是说完全杜绝修改，⽽是以最⼩的修改代码的代价来完成新功能的开发。
第⼆点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能⼜被认定为“扩展”。

⽽且，我们要认识到，添加⼀个新功能，不可能任何模块、类、⽅法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做⼀些初始化操作，才能构建成可运⾏的的程序，这部分代码的修改是在所难免的。
我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核⼼、最复杂的那部分逻辑代码满⾜开闭原则。

如何做到“对扩展开放、修改关闭”？
我们要时刻具备扩展意识、抽象意识、封装意识。在写代码的时候，我们要多花点时间思考⼀下，这段代码未来可能有哪些需求变更，如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，在不改动代码整体结构、
做到最⼩代码改动的情况下，将新的代码灵活地插⼊到扩展点上。

很多设计原则、设计思想、设计模式，都是以提⾼代码的扩展性为最终⽬的的。特别是 23 种经典设计模式，⼤部分都是为了解决代码的扩展性问题⽽总结出来的，都是以开闭原则为指导原则的。
最常⽤来提⾼代码扩展性的⽅法有：多态、依赖注⼊、基于接⼝⽽⾮实现编程，以及⼤部分的设计模式（⽐如，装饰、策略、模板、职责链、状态）。

```