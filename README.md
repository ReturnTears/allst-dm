# Java设计模式
```
dm: design mode 设计模式

原型设计模式问题:
1、UML类图画出原型模式核心角色
2、原型设计模式的深拷贝和浅拷贝是什么
3、在Spring框架中哪里使用到了原型模式
4、Spring中原型bean的创建，就是原型模式的应用
5、代码分析 + Debug源码

设计模式的七大原则
1）、七大设计原则核心思想
2）、能够以类图的说明设计原则
3）、在项目实际开发中，哪里使用到了那些原则

设计模式常用七大原则:
1）、单一职责原则
2）、接口隔离原则
3）、依赖倒转原则
4）、里氏替换原则
5）、开闭原则
6）、迪米特发原则
7）、合成复用原则

设计模式的重要性

```
## 单一职责原则
```
单一职责：single responsibility

```

## 接口隔离原则
```

```

## 依赖倒转原则
```
依赖倒转原则：Dependence Inversion Princle （DIP）
```

## 里氏替换原则
```

```

## 开闭原则
```
开闭原则是编程中最基础最重要的设计原则
用抽象构建框架， 用实现扩展细节
```

## 迪米特法则
```text
注意事项：
1、迪米特法则的核心是降低类之间的耦合
2、注意，由于每个类都减少不必要的依赖，因此迪米特法则只是要求降低类间耦合关系，并不是要求完全的没有依赖关系

```

## 合成复用原则
```text
基本介绍：
原则是尽量使用合成/聚合的方式，而不是使用继承

```

## Java设计模式
```text
UML类图
UML -- Unified modeling language(统一建模语言)

类之间的关系:
依赖、泛化（继承）、实现、关联、聚合、组合
dependence、generalization、implementation、association、aggregation、composition
依赖: 只要是在类中用到了对方， 那么它们之间就存在依赖关系。如果没有对方， 连编译都过不了
泛化: 泛化关系实际上就是继承关系，他是依赖关系的特例
实现:
关联: 关联关系实际上就是类与类之间的联系，它是依赖关系的特例，关联具有导航性，即双向关系或单向关系
聚合: 聚合关系表示的整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例
组合: 聚合关系表示的整体和部分的关系，整体与部分不可以分开。

设计模式概述
模式不是代码，而是某类问题的通用解决方案，设计模式（design pattern）代表了最佳的实践。
这些解决方案是众多软件开发人员经过相当长一段时间的试验和错误总结出来的。
设计模式的本质是提高软件的维护性，通用性和扩展性，并降低软件的复杂度。
并非只有23种设计模式，只是着23种设计模式包括了软件开发种绝大多数的情况

设计模式分类: 共分23种
1)、创建型模式: 单例模式、抽象工程模式、原型模式、建造者模式、工厂模式
2)、结构型模式: 适配器模式、桥接模式、装饰模式、组合模式、外观模式、亨元模式、代理模式
3)、行为型模式: 模板方法模式、命令模式、访问者模式、迭代模式、观察者模式、中介模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式

```

# 设计模式
## 单例模式
```
模式定义：保证一个类只有一个实例，并且提供一个全局访问点
单例模式的注意事项和细节说明:
1、单例模式保证了系统内存中该类只存在一个对象， 节省了系统资源，对于一些需要频繁创建销毁的对象， 使用单例模式可以提高性能
2、当想实例化一个单例类的时候， 必须要记住使用相应的获取对象的方法， 而不是使用new
3、单例模式的使用场景:
   需要频繁的进行创建和销毁的对象，创建对象时耗时过多或耗费资源过多(即：重量级对象)，
   但又经常用到的对象，工具类对象， 频繁访问数据或文件的对象(如：数据源，session工厂)
场景：
重量级的对象， 不需要多个实例，如：线程池，数据库连接池
模式分类:
1、懒汉模式：延迟加载，只有在真正使用的时候才开始实例化
1.1、线程安全问题
1.2、double check 加锁优化
1.3、编译器（JIT），CPU有可能对指令进行重排序，导致使用到尚未初始化的实例，可以通过添加volatile关键字进行修饰
    对于volatile修饰的字段，可以防止指令重排序

2、饿汉模式：类加载的初始化阶段就完成了实例的初始化， 本质上就是借助于JVM的类加载机制，保证实例的唯一性。
类加载的过程：
2.1、加载二进制数据到内存中，生成对应的Class数据结构
2.2、连接：a.验证、b.准备（给类的静态成员变量赋默认值）、c.解析
2.3、初始化：给类的静态变量赋初始值
只有在真正使用对应的类时，才会触发初始化， 如（当前类是启动类即main函数所在类， 直接继续new操作， 访问静态属性， 访问静态方法、用反射访问类、初始化一个类的子类）

3、静态内部类
3.1、本质上是利用类的加载机制来保证线程的安全
3.2、只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一种形式

4、单例模式在源码中的应用
Runtime类运用了饿汉模式
Currency运用了枚举
Tomcat



JVM序列化机制：


这里的线程安全指的是：创建实例的过程
```

## 工厂设计模式
```text
简单工厂模式

抽象工厂模式
定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合
从设计层面看，抽象工厂模式就是对简单工厂模式的改进
将工厂抽象成两层，AbstractFactory(抽象工厂)和具体实现的工厂子类。
应用场景：
程序需要处理不同系列的相关产品， 但是不希望它依赖于这些产品的具体实现类时可以使用抽象工厂
Connection 连接器类就是使用的该模式
主要优点：
1、可以确信你从工厂得到的产品彼此是兼容的
2、可以避免具体产品和客户端之间的紧密耦合
3、符合单一职责原则
4、符合开闭原则


**工厂方法模式**
定义一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类
应用场景：
1、当不知道该使用对象的确切类型的时候
2、当你希望为库或框架提供扩展其内部组件的方法时
主要优点：
1、将具体产品和创建者解耦
2、符合单一职责原则
3、符合开闭原则
***
一个项目的是在不断演变的，如果一个项目是很稳定的，就没有必要使用设计模式；如果一个项目一直在变化， 也灭有必要使用设计模式
引入设计模式的前提是：在项目中找到变化部分中稳定的部分，这样才有使用设计模式的价值。
***

```
